package com.nexusmind;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class AutomationController {

    private static final int FILE_BATCH_SIZE = 5;
    private static final long SLEEP_DURATION_HOURS = 1;
    private static final long ERROR_SLEEP_DURATION_MINUTES = 10;

    public static void main(String[] args) {
        System.out.println("Starting NexusMind Automation (Self-Loop Mode Enabled)...");

        CheckpointManager checkpointManager = new CheckpointManager();
        RepoManager repoManager = new RepoManager(
                "https://github.com/glacious83/NexusMind",
                "C:\\Users\\mmamouze\\IdeaProjects\\NexusMind"
        );
        ImprovementAgent agent = new ImprovementAgent(checkpointManager, repoManager);
        RepoAnalyzer analyzer = new RepoAnalyzer("C:\\Users\\mmamouze\\IdeaProjects\\NexusMind");
        AIPlanner planner = new AIPlanner();
        GitHubIssueManager issueManager = new GitHubIssueManager();

        while (true) {
            System.out.println("\n==== NexusMind New Cycle ====");

            try {
                executeCycle(repoManager, agent, analyzer, planner, issueManager);
                System.out.printf("\nCycle completed. Sleeping for %d hour(s)...%n", SLEEP_DURATION_HOURS);
                sleepHours(SLEEP_DURATION_HOURS);
            } catch (Exception e) {
                handleCycleError(e);
            }
        }
    }

    private static void executeCycle(RepoManager repoManager, ImprovementAgent agent,
                                     RepoAnalyzer analyzer, AIPlanner planner,
                                     GitHubIssueManager issueManager) throws Exception {
        repoManager.updateRepo();
        agent.improveNextFiles(FILE_BATCH_SIZE);

        String projectSummary = analyzer.generateProjectSummary();
        List<String> suggestions = Arrays.asList(planner.generateImprovementSuggestions(projectSummary).split("\n"));

        suggestions.stream()
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .forEach(suggestion -> {
                    String priority = determinePriority(suggestion);
                    String formattedBody = formatIssueBody(suggestion, priority);
                    issueManager.createIssue(suggestion, formattedBody);
                });
    }

    private static String formatIssueBody(String suggestion, String priority) {
        return String.format("""
                ### Overview
                This issue was auto-generated by NexusMind AI.

                ### Problem Description
                %s

                ### Suggested Solution
                _(NexusMind recommends improving this area based on project structure analysis.)_

                ### Priority
                %s

                ### Estimated Complexity
                Medium

                ### Additional Notes
                NexusMind can attempt an automated Pull Request once approved.
                """, suggestion, priority);
    }

    private static String determinePriority(String suggestion) {
        String lower = suggestion.toLowerCase();
        if (lower.contains("security") || lower.contains("critical") || lower.contains("crash") || lower.contains("vulnerability")) {
            return "High";
        } else if (lower.contains("optimize") || lower.contains("performance") || lower.contains("refactor") || lower.contains("improve")) {
            return "Medium";
        }
        return "Low";
    }

    private static void handleCycleError(Exception e) {
        String errorMessage = "Error during cycle: " + e.getMessage();
        System.err.println(errorMessage);
        Notifier.sendError(errorMessage);
        sleepMinutes(ERROR_SLEEP_DURATION_MINUTES);
    }

    private static void sleepHours(long hours) {
        sleep(TimeUnit.HOURS.toMillis(hours));
    }

    private static void sleepMinutes(long minutes) {
        sleep(TimeUnit.MINUTES.toMillis(minutes));
    }

    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
        }
    }
}
